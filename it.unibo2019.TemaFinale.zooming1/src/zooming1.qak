System butlerzooming1

//from maitre to butler
Dispatch prepare : prepare
Dispatch addFood : addFood(C,Q) //C = food code, Q = quantity
Dispatch clean : clean
Dispatch stop : stop
Dispatch reactivate : reactivate

//from butler to butler
Dispatch terminatedTask : terminatedTask
Dispatch nearPantry : nearPantry
Dispatch nearTable : nearTable
Dispatch nearFridge : nearFridge
Dispatch nearTableP : nearTableP
Dispatch inRH : inRH

Dispatch check: check
Dispatch nextMove : nextMove
Dispatch exec : exec
Dispatch calculateRoute : calculateRoute(X) //X = Goal
Dispatch nearPrepare : nearPrepare(X) //X posizione
Dispatch nearAdd : nearAdd(X) //X posizione
Dispatch nearClean : nearClean(X) //X posizione
Dispatch near : near(X)

//from maitre to maitre
Dispatch add : add
Dispatch cl : cl

//from butler to maitre
Dispatch completedTask : completedTask(X)
Dispatch warning : warning(C,Q,AQ)  //C = food code, Q = quantity, AQ = quantità disponibile nel frigo

//from butler to fridge
Dispatch foodAvailability : foodAvailability(C,Q) //C = food code, Q = quantity
Dispatch foodTaken : foodTaken(C,Q) //C = food code, Q = quantity
Dispatch foodPutted : foodPutted(C,Q)   //C = food code, Q = quantity

//from butler to pantry
Dispatch retrieveStateP : retrieveStateP
Dispatch takeDishesP : takeDishesP
Dispatch putDishesP : putDishesP

//from butler to dishwasher
Dispatch retrieveStateD : retrieveStateD
Dispatch takeDishesD : takeDishesD
Dispatch putDishesD : putDishesD

//from pantry to butler
Dispatch returnStateP : returnStateP(X)

//from dishwasher to butler
Dispatch returnStateD : returnStateD(X)

//from fridge to butler
Dispatch positiveResponse : positiveResponse(C,Q)    //C = food code, Q = quantity
Dispatch negativeResponse : negativeResponse(C,Q,AQ) //C = food code, Q = quantity, AQ = quantità disponibile nel frigo

//from fridge to maitre
Dispatch currentFood : currentFood(X)  //in una fase successiva si deciderà come comunicare il contenuto del frigo

Context ctxButler ip[host="localhost" port=8080]
Context ctxMaitre ip[host="localhost" port=8081]
Context ctxFridge ip[host="localhost" port=8082]

QActor butler context ctxButler{
	["var Curmove =\"\";
	  var nextState =\"\"; 
	  var table = 0;
	  var Position = \"\"; 
	  var PosTable = \"\";
	  var Task = \"\";"]
	State s0 initial{
		solve(consult("sysRules.pl"))
		solve(consult("resourceModelButler.pl"))
		println("Butler STARTED")
		
	}Goto waitCmd1
	
	State waitCmd1{
		solve(cmd(robot, task(waiting)))
	}Transition t0 whenMsg prepare -> preparing
	
	//PREPARE ACTION
	
	State preparing{
		println("---BUTLER in preparing")
		//salvo sulla base di conoscenza il task corrente che il butler sta eseguendo.
		["table = 0;"]
		solve(cmd(robot, task(preparing)))
		forward butler -m calculateRoute : calculateRoute(pantry)
	}//Goto planningRoute
	Transition t0 whenMsg calculateRoute -> planningRoute
	
	State planningRoute{
		onMsg(calculateRoute : calculateRoute(GOAL)){
			//lancio il planning che calcola la strada e la salva in una KB
			println("--BUTLER calculate route to ${payloadArg(0)}")
			forward butler -m exec : exec
		}
	}Transition t0 whenMsg exec -> execRoute
				   
	State execRoute{
		//LAB16
		println("--- BUTLER EXEC ROUTE")
		solve(retract(move(M))) //consume a move
		ifSolved {
			["Curmove = getCurSol(\"M\").toString()"]
			println("Exec move $Curmove")
			//richiamo resource per eseguire la mossa
		} else {
			["Curmove=\"nomove\" "]
		}
		if "(Curmove != \"nomove\")"{
			//run itunibo.planner.moveUtils.doPannedMove(myself,Curmove)
			forward butler -m nextMove : nextMove
		}else{
			solve(updatePosition(pantry))
			solve(assert(move(w)))
			solve(assert(move(w)))
			solve(assert(move(w)))
			println("%%%%regole aggiunte")
			forward butler -m check : check
		}
	}Transition t0 whenMsg stop -> stopApplication
				   whenMsg nextMove -> execRoute
				   whenMsg check -> checkPosition
				   
	
	State checkPosition{
		/*
		 * Verifico la posizione in cui mi trovo
		 * ed in base a questa transitio nello prossimo stato
		 */
		 println("---BUTLER in checkPosition")
		 solve(currentTask(robot, task(T)))
		 ifSolved{
		 	["Task = getCurSol(\"T\").toString()"]
		 	println("task = $Task")
		 }
		 solve(currentPosition(robot, position(P)))
		 ifSolved {
		 	["Position = getCurSol(\"P\").toString()"]
		 }
		 if "(Position == \"table\")"{
		 	["table++; Position = Position + table"]
		 }else{
		 	if "(Position == \"inRH\")"{
		 		forward butler -m inRH : inRH
		 	}else{
		 		forward butler -m near : near($Position)
		 	}
		 }
		 /*if "(Position == \"table\")"{
		 	["table++; PosTable = Position + table"]
		 	//forward butler -m near : near($PosTable)
		 	if "(Task == \"preparing\")"{
		 			forward butler -m nearPrepare : nearPrepare($PosTable)
		 		}
		 		if "(Task == \"adding\")"{
		 			forward butler -m nearClean : nearClean($PosTable)
		 		}
		 		if "(Task == \"cleaning\")"{
		 			forward butler -m nearAdd : nearAdd($PosTable)
		 		}
		 }else{
		 	if "(Position == \"inRH\")"{
		 		forward butler -m inRH : inRH
		 	}else{
		 		//forward butler -m near : near($Position)
		 		if "(Task == \"preparing\")"{
		 			forward butler -m nearPrepare : nearPrepare($Position)
		 		}
		 		if "(Task == \"adding\")"{
		 			forward butler -m nearClean : nearClean($Position)
		 		}
		 		if "(Task == \"cleaning\")"{
		 			forward butler -m nearAdd : nearAdd($Position)
		 		}
		 		
		 	}
		 }*/
	}/*Transition t0 whenMsg nearPrepare -> execActionPrepare
				   whenMsg nearAdd  -> execActionAdd
				   whenMsg nearClean -> execActionClean
				   whenMsg inRH -> sendAck*/
	Transition t0 whenMsg near and "Task.equals(\"preparing\")" -> execActionPrepare
				   whenMsg near and "Task == \"adding\""  -> execActionAdd
				   whenMsg near and "Task == \"cleaning\""-> execActionClean
				   whenMsg inRH -> sendAck
	
	State execActionPrepare{
		onMsg(near : near(pantry)){
			println("Butler takes dishes from pantry")
			forward butler -m calculateRoute : calculateRoute(table)
		}
		onMsg(near : neare(fridge)){
			println("Butler takes food from fridge")
			forward butler -m calculateRoute : calculateRoute(table)
		}
		onMsg(near : near(table1)){
			println("Butler puts dishes on table")
			forward butler -m calculateRoute : calculateRoute(fridge)
		}
		onMsg(near : near(table2)){
			println("Butler puts food on table")
			forward butler -m calculateRoute : calculateRoute(rh)
		}
		/*onMsg(nearPrepare : nearPrepare(pantry)){
			println("Butler takes dishes from pantry")
			forward butler -m calculateRoute : calculateRoute(table)
		}
		onMsg(nearPrepare : nearPrepare(fridge)){
			println("Butler takes food from fridge")
			forward butler -m calculateRoute : calculateRoute(table)
		}
		onMsg(nearPrepare : nearPrepare(table1)){
			println("Butler puts dishes on table")
			forward butler -m calculateRoute : calculateRoute(fridge)
		}
		onMsg(nearPrepare : nearPrepare(table2)){
			println("Butler puts food on table")
			forward butler -m calculateRoute : calculateRoute(rh)
		}*/
	}Transition t0 whenMsg calculateRoute -> planningRoute
	
	State sendAck{
		println("Butler finished $Task task")
		forward maitre -m completedTask : completedTask($Task)
		
	}Goto waitCmd1 if "(Task == \"cleaning\")" else waitCmd2
	
	State stopApplication{	
		println("Butler stopping")
	}Transition t0 whenMsg reactivate -> execRoute
	
	
	
	State waitCmd2{
		solve(cmd(robot, task(waiting)))
	}Transition t0 whenMsg addFood -> adding
				   whenMsg clean -> cleaning
	
	State cleaning{
		["table = 0;"]
		solve(cmd(robot, task(cleaning)))	
		forward butler -m calculateRoute : calculateRoute(table)
	}Goto planningRoute
	
	State execActionClean{
		onMsg(nearClean : nearClean(dishwasher)){
			println("Butler puts dishes into dishwasher")
			forward butler -m calculateRoute : calculateRoute(table)
		}
		onMsg(nearClean : nearClean(fridge)){
			println("Butler puts food into fridge")
			forward butler -m calculateRoute : calculateRoute(table)
		}
		onMsg(nearClean : nearClean(table1)){
			println("Butler takes dishes from table")
			forward butler -m calculateRoute : calculateRoute(fridge)
		}
		onMsg(nearClean : nearClean(table2)){
			println("Butler takes food from table")
			forward butler -m calculateRoute : calculateRoute(rh)
		}
	}Transition t0 whenMsg calculateRoute -> planningRoute
				
	State adding{
		onMsg(addFood : addFood(C,Q)){
			["table = 0;"]
		solve(cmd(robot, task(cleaning)))
		forward fridge -m foodAvailability : foodAvailability($payloadArg(0),$payloadArg(1))
		}
	}Transition t0 whenMsg positiveResponse -> nextStep
				   whenMsg negativeResponse -> sendWarning
	
	State nextStep{
		forward butler -m calculateRoute : calculateRoute(fridge)
	}Goto planningRoute	
	
	State sendWarning{
		onMsg(negativeResponse : negativeResponse(C,Q,AQ)){
			forward maitre -m warning : warning($payloadArg(0),$payloadArg(1),$payloadArg(2))
		}
	}Goto waitCmd2
		
	State execActionAdd{
		onMsg(nearAdd : nearAdd(fridge)){
			println("Butler takes food from fridge")
			forward butler -m calculateRoute : calculateRoute(table)
		}
		onMsg(nearAdd : nearAdd(table1)){
			println("Butler puts food on table")
			forward butler -m calculateRoute : calculateRoute(rh)
		}
	}Transition t0 whenMsg calculateRoute -> planningRoute   
	
	
}

QActor maitre context ctxMaitre{
	State s0 initial{
		println("Maitre STARTED")
	}Goto sendingP
	
	State sendingP{
		delay 2000
		println("----Maitre send prepare message")
		forward butler -m prepare : prepare
	}Goto waitingPAck
	
	State waitingPAck{
		//eventualmente in questo stato posso mandare un messaggio di stop, reactivate
		onMsg(completedTask : completedTask(T)){
			println("Butler finito ${payloadArg(0)} task")
		}
	}/*Transition t0 whenMsg completedTask -> sendingAC
				   whenMsg currentFood -> updateFP*/
	
	State sendingAC{
		forward butler -m addFood : addFood(2,2)
		forward maitre -m add : add
		/*forward butler -m clear : clear
		forward maitre -m cl : cl*/
	}Transition t0 whenMsg add -> waitingAfAck
				   whenMsg cl -> waitingClAck
	
	State waitingAfAck{
		printCurrentMessage
	}Transition t0 whenMsg completedTask -> sendingAC
				   whenMsg currentFood -> updateFA
	
	State waitingClAck{
		printCurrentMessage
	}Transition t0 whenMsg completedTask -> sendingP
				   whenMsg currentFood -> updateFC
				   
	State updateFP{
		//aggiorno informazioni sul contenuto del frigo
	}
	
	State updateFC{
		//aggiorno informazioni sul contenuto del frigo
	}
	
	State updateFA{
		//aggiorno informazioni sul contenuto del frigo
	}
}

QActor fridge context ctxFridge{
	["var Quantity = 0;"]
	State s0 initial{
		println("Fridge STARTED")
		solve(consult("sysRules.pl"))
		solve(consult("fridgeContent.pl"))
		println("----FRIDGE : comunico al maitre il mio contenuto")
		//forward maitre -m currentFood : currentFood(lista)
	}Goto waitCmd
	
	State waitCmd{
		
	}Transition t0 whenMsg foodAvailability -> checking
				   whenMsg foodTaken -> updatingTf
				   whenMsg foodPutted -> updatingPf
				   
	State checking{
		onMsg(foodAvailability : foodAvailability(Code, Quant)){
			solve(food($payloadArg(0), Q))
			ifSolved {
				["Quantity = getCurSol(\"Q\").toString().toInt()"]
			}
			if "Quantity <= payloadArg(1).toString().toInt()"{
				forward butler -m positiveResponse : positiveResponse
			}else{
				forward butler -m negativeResponse : negativeResponse($payloadArg(0),$payloadArg(1),$Quantity)
			}
		}
	}Goto waitCmd
	
	/*
	 * Dispatch takeFood : takeFood(C,Q) //C = food code, Q = quantity
	   Dispatch putFood : putFood(C,Q)   //C = food code, Q = quantity 
	 */
	State updatingTf{
		["var QA = 0; 
		  var Diff = 0"]
		onMsg(foodTaken : foodTaken(Code, Quant)){
			//vedo la quantità disponibile
			solve(food($payloadArg(0), QA))
			ifSolved{
				["QA = getCurSol(\"QA\").toString().toInt();
				  Diff = QA - payloadArg(1).toString().toInt()"]
			}
			solve(updateQuantity($payloadArg(0), $Diff ))
			//comunico il cambiamento al maitre
		}
	}Goto s0
	
	State updatingPf{
		["var QA = 0; 
		  var Diff = 0"]
		onMsg(foodPutted : foodPutted(Code, Quant)){
			//vedo la quantità disponibile
			solve(food($payloadArg(0), QA))
			ifSolved{
				["QA = getCurSol(\"QA\").toString().toInt();
				  Diff = QA + payloadArg(1).toString().toInt()"]
			}
			solve(updateQuantity($payloadArg(0), $Diff ))
			//comunico il cambiamento al maitre
		}
	}Goto s0
}

QActor pantry context ctxButler{
	State s0 initial{
		println("Pantry STARTED")
	}Goto waitCmd
	
	State waitCmd{
		
	}Transition t0 whenMsg retrieveStateP -> retrieving
				   whenMsg takeDishesP -> taking
				   whenMsg putDishesP -> putting
	
	State retrieving{
		//richiamo il metodo per conoscere lo stato 
	}Goto waitCmd
	
	State taking{
		//richiamato il metodo per prelevare i piatti
	}Goto waitCmd
	
	State putting{
		//richiamo il metodo per inserire i piatti nella pantry
	}Goto waitCmd
}

QActor dishwasher context ctxButler{
	State s0 initial{
		println("Dishwasher STARTED")
	}Goto waitCmd
	
	State waitCmd{
		
	}Transition t0 whenMsg retrieveStateD -> retrieving
				   whenMsg takeDishesD -> taking
				   whenMsg putDishesD -> putting
	
	State retrieving{
		//richiamo il metodo per conoscere lo stato
	}Goto waitCmd
	
	State taking{
		//richiamo il metodo per prelevare i piatti
	}Goto waitCmd
	
	State putting{
		//richiamo il metodo per inserire i piatti
	}Goto waitCmd
}